class CharacterController : ZilchComponent
{
  sends MovementStarted : MovementEvent;
  sends MovementEnded : MovementEvent;
  sends MovementFailed : MovementEvent;
  sends AttemptCollect : CollectionEvent;
  
  
  [Dependency]
  var Transform : Transform;
  
  
  [Property]
  var WallColliderPath : CogPath;
  
  var WallCollider : Collider;
  
  var WallFilter : CastFilter = CastFilter();
  var CollectionFilter : CastFilter = CastFilter();
  var MovementDuration : Real = 4 / 60.0;
  var MovementSequence : ActionSequence;
  var CanMove : Boolean
  {
    get
    {
      var attacking = Zero.Keyboard.KeyIsDown(Keys.Space);
      
      return !attacking;
    }
  }
  
  var Gold : Integer = 0;
  var Keys : Integer = 0;
  
  
  function Initialize(init : CogInitializer)
  {
    this.WallCollider = this.WallColliderPath.Collider;
    this.MovementSequence = Action.Sequence(this.Owner.Actions);
    this.CollectionFilter.IgnoreGhost = false;
    
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
  }
  
  
  function OnKeyDown(event : KeyboardEvent)
  {
    if (event.Key == Keys.Left)
      this.AttemptMoveLeft();
    if (event.Key == Keys.Right)
      this.AttemptMoveRight();
    if (event.Key == Keys.Up)
      this.AttemptMoveUp();
    if (event.Key == Keys.Down)
      this.AttemptMoveDown();
  }
  
  
  function AttemptMoveLeft()
  {
    if (this.CanMove)
      this.MoveLeft();
  }
  
  
  function AttemptMoveRight()
  {
    if (this.CanMove)
      this.MoveRight();
  }
  
  
  function AttemptMoveUp()
  {
    if (this.CanMove)
      this.MoveUp();
  }
  
  
  function AttemptMoveDown()
  {
    if (this.CanMove)
      this.MoveDown();
  }
  
  
  function MoveLeft()
  {
    var me = MovementEvent();
    me.OldPosition = this.Transform.WorldTranslation;
    me.NewPosition = me.OldPosition - Real3.XAxis;
    this.Owner.DispatchEvent(Events.MovementStarted, me);
    
    this.Move(me);
  }
  
  
  function MoveRight()
  {
    var me = MovementEvent();
    me.OldPosition = this.Transform.WorldTranslation;
    me.NewPosition = me.OldPosition + Real3.XAxis;
    this.Owner.DispatchEvent(Events.MovementStarted, me);
    
    this.Move(me);
  }
  
  
  function MoveUp()
  {
    var me = MovementEvent();
    me.OldPosition = this.Transform.WorldTranslation;
    me.NewPosition = me.OldPosition + Real3.YAxis;
    this.Owner.DispatchEvent(Events.MovementStarted, me);
    
    this.Move(me);
  }
  
  
  function MoveDown()
  {
    var me = MovementEvent();
    me.OldPosition = this.Transform.WorldTranslation;
    me.NewPosition = me.OldPosition - Real3.YAxis;
    this.Owner.DispatchEvent(Events.MovementStarted, me);
    
    this.Move(me);
  }
  
  
  function Move(me : MovementEvent)
  {
    var offset = me.NewPosition - me.OldPosition;
    var moveResults = this.Space.PhysicsSpace.CastCollider(offset, this.WallCollider, this.WallFilter);
    var solid = moveResults.IsNotEmpty;
    var collectResults = this.Space.PhysicsSpace.CastCollider(offset, this.WallCollider, this.CollectionFilter);
    
    foreach (var result in collectResults)
    {
      this.AttemptCollect(result.ObjectHit);
    }
    
    this.MovementSequence.Cancel();
    this.MovementSequence = Action.Sequence(this.Owner.Actions);
      
      Action.Delay(this.MovementSequence, this.MovementDuration);
      
      if (solid)
        Action.Call(this.MovementSequence, this.DispatchMovementFailed, me.OldPosition, me.NewPosition);
      else
        Action.Property(this.MovementSequence, @this.Transform.WorldTranslation, me.NewPosition, 0, Ease.Linear);
      
      Action.Call(this.MovementSequence, this.EndOfMovement, me.OldPosition, me.NewPosition);
  }
  
  
  function EndOfMovement(oldPosition : Real3, newPosition : Real3)
  {
    var me = MovementEvent();
    me.OldPosition = oldPosition;
    me.NewPosition = newPosition;
    this.Owner.DispatchEvent(Events.MovementEnded, me);
  }
  
  
  function DispatchMovementFailed(oldPosition : Real3, newPosition : Real3)
  {
    var me = MovementEvent();
    me.OldPosition = oldPosition;
    me.NewPosition = newPosition;
    this.Owner.DispatchEvent(Events.MovementFailed, me);
  }
  
  
  function AttemptCollect(cog : Cog)
  {
    var ce = CollectionEvent();
    cog.DispatchEvent(Events.AttemptCollect, ce);
    
    var collectable = ce.Collectable;
    
    if (collectable != null)
    {
      if (collectable.Keys > 0)
      {
        // TODO:
        // dispatch feedback for getting keys
        
        this.Keys += collectable.Keys;
      }
      
      if (collectable.Gold > 0)
      {
        // TODO:
        // dispatch feedback for getting gold
        
        this.Gold += collectable.Gold;
      }
    }
  }
}


class MovementEvent : ZilchEvent
{
  var OldPosition : Real3;
  var NewPosition : Real3;
}
