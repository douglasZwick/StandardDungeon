class Inventory : ZilchComponent
{
  sends GoldTotalChanged : InventoryEvent;
  sends KeysTotalChanged : InventoryEvent;
  
  
  [Dependency]
  var Transform : Transform;
  
  
  [Property]
  var Gold : Integer = 0;
  [Property]
  var Keys : Integer = 0;
  [Property]
  var DropOnDeath : Boolean = true;
  [Property]
  var LootArchetype : Archetype = Archetype.Loot;
  
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Owner, Events.DidCollect, this.OnDidCollect);
    Zero.Connect(this.Owner, Events.DoorUnlocked, this.OnDoorUnlocked);
    Zero.Connect(this.Owner, Events.ChestUnlocked, this.OnChestUnlocked);
    Zero.Connect(this.Owner, Events.Death, this.OnDeath);
  }
  
  
  function OnDidCollect(event : CollectionEvent)
  {
    var collectable = event.Collectable;
    
    var oldGold = this.Gold;
    var oldKeys = this.Keys;
    
    this.Gold += collectable.Gold;
    this.Keys += collectable.Keys;
    
    var ie = InventoryEvent();
    
    if (oldGold != this.Gold)
    {
      ie.OldTotal = oldGold;
      ie.NewTotal = this.Gold;
      this.Owner.DispatchEvent(Events.GoldTotalChanged, ie);
    }
    
    if (oldKeys != this.Keys)
    {
      ie.OldTotal = oldKeys;
      ie.NewTotal = this.Keys;
      this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
    }
  }
  
  
  function OnDoorUnlocked(event : DoorEvent)
  {
    var locks = event.Door.Locks;
    
    var oldKeys = this.Keys;
    
    this.Keys -= locks;
    
    var ie = InventoryEvent();
    ie.OldTotal = oldKeys;
    ie.NewTotal = this.Keys;
    this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
  }
  
  
  function OnChestUnlocked(event : ChestEvent)
  {
    // TODO: it is totally plain that this two-component approach is badong
    
    var locks = event.Chest.Locks;
    
    var oldKeys = this.Keys;
    
    this.Keys -= locks;
    
    var ie = InventoryEvent();
    ie.OldTotal = oldKeys;
    ie.NewTotal = this.Keys;
    this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
  }
  
  
  function OnDeath(event : HealthEvent)
  {
    // TODO: this approach will likely have a problem where enemies that
    // can collect stuff might end up collecting this loot just before
    // they get destroyed
    
    // TODO: make a new loot sprite
    
    // TODO: maybe factor this stuff out to some kind of DropOnDeath
    // component
    
    var position = this.Transform.WorldTranslation;
    var loot = this.Space.CreateAtPosition(this.LootArchetype, position);
    loot.Collectable.Gold = this.Gold;
    loot.Collectable.Keys = this.Keys;
  }
}


class InventoryEvent : ZilchEvent
{
  var OldTotal : Integer;
  var NewTotal : Integer;
}
