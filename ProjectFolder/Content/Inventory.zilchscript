class Inventory : ZilchComponent
{
  sends GoldTotalChanged : InventoryEvent;
  sends KeysTotalChanged : InventoryEvent;
  sends WasAddedToInventory : CollectionEvent;
  sends DidAddToInventory : CollectionEvent;
  sends RequestDropFromInventory : CollectionEvent;
  sends WasDroppedFromInventory : CollectionEvent;
  sends DidDropFromInventory : CollectionEvent;
  sends RequestUse : InventoryItemEvent;
  sends WasUsed : InventoryItemEvent;
  sends DidUse : InventoryItemEvent;
  
  
  [Dependency]
  var Transform : Transform;
  
  
  [Property]
  var Gold : Integer = 0;
  [Property]
  var Keys : Integer = 0;
  [Property]
  var DropOnDeath : Boolean = true;
  [Property]
  var LootArchetype : Archetype = Archetype.Loot;
  [Property][Group("Internal")]
  var InventoryRoot : CogPath = CogPath(".");
  
  var HeldItem : InventoryItem;
  
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Owner, Events.DidCollect, this.OnDidCollect);
    Zero.Connect(this.Owner, Events.DidOpen, this.OnDidOpen);
    Zero.Connect(this.Owner, Events.Death, this.OnDeath);
    Zero.Connect(this.Owner, Events.DidDropFromInventory, this.OnDidDropFromInventory);
    Zero.Connect(this.Owner, Events.DidAddToInventory, this.OnDidAddToInventory);
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
  }
  
  
  function OnKeyDown(event : KeyboardEvent)
  {
    // TODO: fix this
    if (event.Key == Keys.Shift)
      this.AttemptUse();
  }
  
  
  function OnDidAddToInventory(event : CollectionEvent)
  {
    this.HeldItem = event.InventoryItem;
    this.HeldItem.Owner.AttachTo(this.InventoryRoot.Cog);
    this.HeldItem.Owner.Transform.LocalTranslation = Real3.Zero;
  }
  
  
  function OnDidDropFromInventory(event : CollectionEvent)
  {
    this.HeldItem.Owner.Detach();
    this.HeldItem.Owner.Transform.WorldTranslation = event.WorldPosition;
    this.HeldItem = null;
  }
  
  
  function OnDidCollect(event : CollectionEvent)
  {
    var collectable = event.Collectable;
    var inventoryItem = event.InventoryItem;
    
    if (inventoryItem != null)
    {
      if (this.HeldItem != null)
      {
        event.DroppedItem = this.HeldItem;
        this.HeldItem.Owner.DispatchEvent(Events.WasDroppedFromInventory, event);
        this.Owner.DispatchEvent(Events.DidDropFromInventory, event);
      }
      
      collectable.Owner.DispatchEvent(Events.WasAddedToInventory, event);
      this.Owner.DispatchEvent(Events.DidAddToInventory, event);
    }
    
    var oldGold = this.Gold;
    var oldKeys = this.Keys;
    
    this.Gold += collectable.Gold;
    this.Keys += collectable.Keys;
    
    var ie = InventoryEvent();
    
    if (oldGold != this.Gold)
    {
      ie.OldTotal = oldGold;
      ie.NewTotal = this.Gold;
      this.Owner.DispatchEvent(Events.GoldTotalChanged, ie);
    }
    
    if (oldKeys != this.Keys)
    {
      ie.OldTotal = oldKeys;
      ie.NewTotal = this.Keys;
      this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
    }
  }
  
  
  function OnDidOpen(event : OpenEvent)
  {
    var locks = event.Openable.Locks;
    var oldKeys = this.Keys;
    this.Keys -= locks;
    
    var ie = InventoryEvent();
    ie.OldTotal = oldKeys;
    ie.NewTotal = this.Keys;
    this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
  }
  
  
  function OnDeath(event : HealthEvent)
  {
    // TODO: this approach will likely have a problem where enemies that
    // can collect stuff might end up collecting this loot just before
    // they get destroyed
    
    // TODO: make a new loot sprite
    
    // TODO: maybe factor this stuff out to some kind of DropOnDeath
    // component
    
    var position = this.Transform.WorldTranslation;
    var loot = this.Space.CreateAtPosition(this.LootArchetype, position);
    loot.Collectable.Gold = this.Gold;
    loot.Collectable.Keys = this.Keys;
    
    // TODO: ultimately this is going to require a collider cast to see
    // whether there is already anything here. if there is, then it
    // should be added to this dropped loot
  }
  
  
  function AttemptUse()
  {
    if (this.HeldItem == null)
      return;
    
    var iie = InventoryItemEvent();
    iie.UserInventory = this;
    this.HeldItem.Owner.DispatchEvent(Events.RequestUse, iie);
  }
}


class InventoryEvent : ZilchEvent
{
  var OldTotal : Integer;
  var NewTotal : Integer;
}
