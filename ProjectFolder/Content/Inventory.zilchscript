class Inventory : ZilchComponent
{
  sends GoldTotalChanged : InventoryEvent;
  sends KeysTotalChanged : InventoryEvent;
  sends WasAddedToInventory : CollectionEvent;
  sends DidAddToInventory : CollectionEvent;
  sends RequestDropFromInventory : CollectionEvent;
  sends WasDroppedFromInventory : CollectionEvent;
  sends DidDropFromInventory : CollectionEvent;
  sends RequestUse : InventoryItemEvent;
  sends WasUsed : InventoryItemEvent;
  sends DidUse : InventoryItemEvent;
  sends PutItemIconInInventory : CollectionEvent;
  sends RemoveItemIconFromInventory : CollectionEvent;
  
  
  [Dependency]
  var Transform : Transform;
  
  
  [Property]
  var Gold : Integer = 0;
  [Property]
  var Keys : Integer = 0;
  [Property]
  var DropOnDeath : Boolean = true;
  [Property]
  var LootArchetype : Archetype = Archetype.Loot;
  [Property][Group("Internal")]
  var InventoryRoot : CogPath = CogPath(".");
  
  var HeldItem : InventoryItem;
  
  var DroppedVerbs : Array[String] = Array[String]()
  {
    "dropped",
    "got rid of",
    "ditched",
    "let go of",
    "lost interest in",
    "no longer has",
  };
  
  var GotVerbs : Array[String] = Array[String]()
  {
    "got",
    "picked up",
    "snagged",
    "scored",
    "got ahold of",
    "now has",
  };
  
  var RNG : Random = Random();
  var RandomDroppedVerb : String { get { return this.DroppedVerbs[this.RNG.DieRoll(this.DroppedVerbs.Count) - 1]; }}
  var RandomGotVerb : String { get { return this.GotVerbs[this.RNG.DieRoll(this.GotVerbs.Count) - 1]; }}
  
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Owner, Events.DidCollect, this.OnDidCollect);
    Zero.Connect(this.Owner, Events.DidOpen, this.OnDidOpen);
    Zero.Connect(this.Owner, Events.Death, this.OnDeath);
    Zero.Connect(this.Owner, Events.DidDropFromInventory, this.OnDidDropFromInventory);
    Zero.Connect(this.Owner, Events.DidAddToInventory, this.OnDidAddToInventory);
    Zero.Connect(this.Owner, Events.DidUseUp, this.OnDidUseUp);
    Zero.Connect(Zero.Keyboard, Events.KeyDown, this.OnKeyDown);
  }
  
  
  function OnKeyDown(event : KeyboardEvent)
  {
    // TODO: fix this
    if (event.Key == Keys.Shift)
      this.AttemptUse();
  }
  
  
  function OnDidAddToInventory(event : CollectionEvent)
  {
    this.HeldItem = event.InventoryItem;
    this.HeldItem.Owner.AttachTo(this.InventoryRoot.Cog);
    this.HeldItem.Owner.Transform.LocalTranslation = Real3.Zero;
    
    // TODO: i'm finding it hard to justify to myself the need for all these
    // event classes that seem to have so much overlap in their use. should
    // PutItemIconInInventory actually use a CollectionEvent? seems weird
    // when there's also an InventoryEvent and also an InventoryItemEvent. a
    // refactor of these classes seems to be in order
    
    this.GameSession.DispatchEvent(Events.PutItemIconInInventory, event);
  }
  
  
  function OnDidDropFromInventory(event : CollectionEvent)
  {
    this.HeldItem.Owner.Detach();
    this.HeldItem.Owner.Transform.WorldTranslation = event.WorldPosition;
    this.HeldItem = null;
    
    // TODO: currently there are two ways to lose an item from your inventory:
    // either you drop it (because you picked something else up), or you use
    // it up. i should consider refactoring things so that both cases use the
    // same code interface
    
    this.GameSession.DispatchEvent(Events.RemoveItemIconFromInventory, event);
  }
  
  
  function OnDidUseUp(event : InventoryItemEvent)
  {
    var ce = CollectionEvent();
    ce.InventoryItem = event.InventoryItem;
    this.GameSession.DispatchEvent(Events.RemoveItemIconFromInventory, ce);
  }
  
  
  function OnDidCollect(event : CollectionEvent)
  {
    var collectable = event.Collectable;
    var inventoryItem = event.InventoryItem;
    
    if (inventoryItem != null)
    {
      var collectedItemBase = inventoryItem.ItemBase;
      var collectedNamePhrase = collectedItemBase.NamePhrase;
      
      if (this.HeldItem != null)
      {
        var droppedItemBase = this.HeldItem.ItemBase;
        var droppedNamePhrase = droppedItemBase.NamePhrase;
        var string0 = "Poocha `this.RandomDroppedVerb` `droppedNamePhrase`";
        var string1 = "and `this.RandomGotVerb` `collectedNamePhrase`";
        var cse = ConsoleSystemEvent(string0, string1);
        this.GameSession.DispatchEvent(Events.Print, cse);
        
        event.DroppedItem = this.HeldItem;
        this.HeldItem.Owner.DispatchEvent(Events.WasDroppedFromInventory, event);
        this.Owner.DispatchEvent(Events.DidDropFromInventory, event);
      }
      else
      {
        var string0 = "Poocha `this.RandomGotVerb` `collectedNamePhrase`";
        var cse = ConsoleSystemEvent(string0);
        this.GameSession.DispatchEvent(Events.Print, cse);
      }
      
      collectable.Owner.DispatchEvent(Events.WasAddedToInventory, event);
      this.Owner.DispatchEvent(Events.DidAddToInventory, event);
    }
    
    var oldGold = this.Gold;
    var oldKeys = this.Keys;
    
    this.Gold += collectable.Gold;
    this.Keys += collectable.Keys;
    
    var ie = InventoryEvent();
    
    if (oldGold != this.Gold)
    {
      ie.OldTotal = oldGold;
      ie.NewTotal = this.Gold;
      this.Owner.DispatchEvent(Events.GoldTotalChanged, ie);
    }
    
    if (oldKeys != this.Keys)
    {
      ie.OldTotal = oldKeys;
      ie.NewTotal = this.Keys;
      this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
    }
  }
  
  
  function OnDidOpen(event : OpenEvent)
  {
    var locks = event.Openable.Locks;
    var oldKeys = this.Keys;
    this.Keys -= locks;
    
    var ie = InventoryEvent();
    ie.OldTotal = oldKeys;
    ie.NewTotal = this.Keys;
    this.Owner.DispatchEvent(Events.KeysTotalChanged, ie);
  }
  
  
  function OnDeath(event : HealthEvent)
  {
    // TODO: this approach will likely have a problem where enemies that
    // can collect stuff might end up collecting this loot just before
    // they get destroyed
    
    // TODO: make a new loot sprite
    
    // TODO: maybe factor this stuff out to some kind of DropOnDeath
    // component
    
    var position = this.Transform.WorldTranslation;
    var loot = this.Space.CreateAtPosition(this.LootArchetype, position);
    loot.Collectable.Gold = this.Gold;
    loot.Collectable.Keys = this.Keys;
    
    // TODO: ultimately this is going to require a collider cast to see
    // whether there is already anything here. if there is, then it
    // should be added to this dropped loot
  }
  
  
  function AttemptUse()
  {
    if (this.HeldItem == null)
      return;
    
    var iie = InventoryItemEvent();
    iie.UserInventory = this;
    this.HeldItem.Owner.DispatchEvent(Events.RequestUse, iie);
  }
}


class InventoryEvent : ZilchEvent
{
  var OldTotal : Integer;
  var NewTotal : Integer;
}
